//! Модуль конфигурации приложения.
//!
//! Этот модуль отвечает за загрузку и управление конфигурацией приложения
//! из файла `config.toml` и переменных окружения.
//!
//! # Для студентов: Управление конфигурацией
//!
//! ## Зачем нужен отдельный модуль конфигурации?
//!
//! 1. **Разделение кода и настроек** - изменение настроек не требует перекомпиляции
//! 2. **Разные окружения** - development, staging, production
//! 3. **Безопасность** - секреты (токены) хранятся в переменных окружения
//!
//! ## Иерархия источников конфигурации
//!
//! ```text
//! Приоритет (от низкого к высокому):
//!
//! 1. config.toml         - базовые настройки (в репозитории)
//! 2. .env файл           - локальные переопределения (НЕ в репозитории)
//! 3. Переменные окружения - настройки на сервере/в Docker
//!
//! Более высокий приоритет ПЕРЕОПРЕДЕЛЯЕТ более низкий.
//! ```
//!
//! ## Почему TOML?
//!
//! TOML (Tom's Obvious, Minimal Language) - формат конфигурации:
//! - Более читаемый, чем JSON (поддерживает комментарии)
//! - Проще, чем YAML (меньше "магии" с отступами)
//! - Нативная поддержка в экосистеме Rust (Cargo.toml)
//!
//! # Примеры
//!
//! ```rust,ignore
//! let config = AppConfig::load().expect("Не удалось загрузить конфигурацию");
//! println!("Сервер: {}:{}", config.server.address, config.server.port);
//! ```

// ============================================================================
// ИМПОРТЫ
// ============================================================================

// Deserialize - трейт для создания структуры из внешних данных (TOML, JSON и т.д.)
use serde::Deserialize;

// std::env - работа с переменными окружения операционной системы
use std::env;

// thiserror - макрос для создания типов ошибок
use thiserror::Error;

// ============================================================================
// ТИПЫ ОШИБОК
// ============================================================================

/// Ошибки, которые могут возникнуть при работе с конфигурацией.
///
/// # Для студентов: Атрибут #[from]
///
/// `#[from]` автоматически реализует `From<T>` для enum-варианта.
/// Это позволяет использовать `?` для автоматического преобразования ошибок:
///
/// ```rust,ignore
/// // Без #[from] пришлось бы писать:
/// let settings = config::Config::builder().build()
///     .map_err(|e| ConfigError::LoadError(e))?;
///
/// // С #[from] можно просто:
/// let settings = config::Config::builder().build()?;
/// ```
#[derive(Error, Debug)]
pub enum ConfigError {
    /// Ошибка при загрузке/парсинге конфигурационного файла
    #[error("Не удалось загрузить конфигурацию: {0}")]
    LoadError(#[from] config::ConfigError),  // #[from] - автоматическое преобразование

    /// Ошибка при чтении переменной окружения (отсутствует или невалидна)
    #[error("Не удалось прочитать переменную окружения: {0}")]
    EnvError(#[from] env::VarError),
}

// ============================================================================
// СТРУКТУРЫ КОНФИГУРАЦИИ
// ============================================================================

/// Основная структура конфигурации приложения.
///
/// # Для студентов: Сравнение с models/mod.rs
///
/// Обратите внимание на ОТЛИЧИЯ в derive-атрибутах:
///
/// ```text
/// // config/mod.rs (этот файл):
/// #[derive(Debug, Deserialize, Clone)]    // ← Clone нужен!
/// // НЕТ #[serde(crate = "rocket::serde")] // ← НЕ нужен!
///
/// // models/mod.rs:
/// #[derive(Debug, Serialize)]              // ← Clone НЕ нужен
/// #[serde(crate = "rocket::serde")]        // ← НУЖЕН для Rocket
/// ```
///
/// ## Почему здесь Clone?
///
/// Конфигурация передаётся в несколько мест:
/// - В Rocket через `.manage(config.clone())`
/// - В AiServiceFactory
/// - Сохраняется для логирования
///
/// Без Clone пришлось бы использовать `Arc<AppConfig>` или передавать по ссылке.
///
/// ## Почему НЕТ `#[serde(crate = "rocket::serde")]`?
///
/// Эти структуры используются с библиотекой `config`, а не с Rocket.
/// `config` crate имеет СВОЮ зависимость на serde, которая совместима
/// со стандартным `serde = "1.0"` из нашего Cargo.toml.
///
/// ```text
/// models/mod.rs  →  Rocket  →  rocket::serde
/// config/mod.rs  →  config  →  serde (стандартный)
/// ```
///
/// ## Почему только Deserialize?
///
/// Конфигурацию мы только ЧИТАЕМ из файла, никогда не записываем обратно.
///
/// # Структура TOML-файла
///
/// ```toml
/// [server]
/// address = "127.0.0.1"
/// port = 8000
///
/// [gigachat]
/// enabled = false
/// ```
///
/// Serde автоматически сопоставляет секции TOML с полями структуры!
#[derive(Debug, Deserialize, Clone)]
pub struct AppConfig {
    /// Настройки HTTP-сервера
    pub server: ServerConfig,
    
    /// Настройки интеграции с GigaChat API
    pub gigachat: GigaChatConfig,
    
    /// Настройки системы логирования
    pub logging: LoggingConfig,
    
    /// Мета-информация о приложении
    pub application: ApplicationConfig,
}

/// Конфигурация HTTP-сервера.
///
/// Соответствует секции `[server]` в config.toml
#[derive(Debug, Deserialize, Clone)]
pub struct ServerConfig {
    /// IP-адрес для прослушивания.
    /// "127.0.0.1" - только локальные подключения
    /// "0.0.0.0" - подключения с любого IP (для Docker)
    pub address: String,
    
    /// TCP-порт для HTTP-сервера (1-65535)
    /// Стандартные: 80 (HTTP), 443 (HTTPS), 8000/8080 (разработка)
    pub port: u16,
    
    /// Окружение: "development" или "production"
    /// Влияет на уровень логирования и отображение ошибок
    pub environment: String,
}

/// Конфигурация интеграции с GigaChat API.
///
/// Соответствует секции `[gigachat]` в config.toml
///
/// # Для студентов: Параметры генерации текста
///
/// AI-модели имеют настраиваемые параметры:
/// - **temperature** - "креативность" (0.0 = детерминированно, 1.0 = случайно)
/// - **max_tokens** - максимальная длина ответа
/// - **model** - версия модели (разные по скорости/качеству)
#[derive(Debug, Deserialize, Clone)]
pub struct GigaChatConfig {
    /// Использовать ли реальный API (true) или mock (false)
    pub enabled: bool,
    
    /// Идентификатор модели GigaChat
    pub model: String,
    
    /// Максимум токенов в ответе (примерно 1 токен ≈ 4 символа)
    pub max_tokens: u32,
    
    /// Температура генерации: 0.0 (точно) - 1.0 (креативно)
    pub temperature: f32,
    
    /// Таймаут HTTP-запроса в секундах
    pub timeout_seconds: u64,
}

/// Конфигурация системы логирования.
///
/// Соответствует секции `[logging]` в config.toml
#[derive(Debug, Deserialize, Clone)]
pub struct LoggingConfig {
    /// Минимальный уровень логов: "trace", "debug", "info", "warn", "error"
    pub level: String,
    
    /// Формат вывода: "json" или "pretty"
    pub format: String,
}

/// Мета-информация о приложении.
///
/// Соответствует секции `[application]` в config.toml
#[derive(Debug, Deserialize, Clone)]
pub struct ApplicationConfig {
    /// Название приложения (отображается в логах и API)
    pub name: String,
    
    /// Семантическая версия (SemVer): MAJOR.MINOR.PATCH
    pub version: String,
    
    /// Краткое описание приложения
    pub description: String,
    
    /// Системный промпт - инструкции для AI (определяет "личность")
    pub system_prompt: String,
}

// ============================================================================
// РЕАЛИЗАЦИЯ AppConfig
// ============================================================================

impl AppConfig {
    /// Загружает конфигурацию из файла и переменных окружения.
    ///
    /// # Для студентов: Паттерн "Строитель" (Builder Pattern)
    ///
    /// Библиотека `config` использует Builder для создания конфигурации:
    ///
    /// ```text
    /// Config::builder()              // Создаём "строителя"
    ///     .add_source(File...)       // Добавляем источник 1
    ///     .add_source(Environment...)  // Добавляем источник 2
    ///     .build()                   // Строим финальный объект
    /// ```
    ///
    /// ## Порядок загрузки (важно!)
    ///
    /// ```text
    /// ┌─────────────────┐
    /// │ 1. .env файл    │  ← dotenv::dotenv() загружает в переменные окружения
    /// └────────┬────────┘
    ///          ↓
    /// ┌─────────────────┐
    /// │ 2. config.toml  │  ← Базовые значения
    /// └────────┬────────┘
    ///          ↓
    /// ┌─────────────────┐
    /// │ 3. APP_* env    │  ← Переопределяют config.toml
    /// └────────┬────────┘
    ///          ↓
    /// ┌─────────────────┐
    /// │ AppConfig       │  ← Финальная структура
    /// └─────────────────┘
    /// ```
    ///
    /// # Ошибки
    ///
    /// Возвращает `ConfigError`, если:
    /// - Файл config.toml не найден
    /// - Файл содержит синтаксические ошибки
    /// - Типы полей не совпадают (например, строка вместо числа)
    pub fn load() -> Result<Self, ConfigError> {
        // Загружаем переменные окружения из файла .env (если он существует).
        // .ok() превращает Result в Option, игнорируя ошибки.
        // Это нормально - файл .env опционален.
        dotenv::dotenv().ok();

        // Позволяем переопределить путь к конфигу через переменную окружения.
        // unwrap_or_else - если переменная не найдена, используем значение по умолчанию.
        let config_path = env::var("CONFIG_PATH")
            .unwrap_or_else(|_| "config.toml".to_string());

        // Создаём конфигурацию с помощью Builder Pattern
        let settings = config::Config::builder()
            // Источник 1: TOML-файл
            .add_source(config::File::with_name(&config_path))
            // Источник 2: Переменные окружения с префиксом APP_
            // Например: APP_SERVER_PORT=9000 → server.port = 9000
            .add_source(
                config::Environment::with_prefix("APP")
                    .separator("_")       // APP_SERVER_PORT → server.port
                    .try_parsing(true),   // Пытаться парсить "9000" как число
            )
            .build()?;  // ? - пробрасываем ошибку, если build() вернул Err

        // Десериализуем в нашу структуру.
        // Serde проверит, что все обязательные поля есть и типы совпадают.
        let config: AppConfig = settings.try_deserialize()?;

        Ok(config)
    }

    /// Возвращает токен GigaChat из переменной окружения.
    ///
    /// # Для студентов: Почему токен в переменной окружения?
    ///
    /// Секреты (пароли, токены, ключи API) НИКОГДА не хранят в коде или config.toml!
    /// 
    /// Причины:
    /// 1. config.toml часто попадает в git → секрет утечёт
    /// 2. Разные окружения требуют разных токенов (dev/prod)
    /// 3. Переменные окружения легко настраиваются в Docker/CI/CD
    ///
    /// ## Как установить токен
    ///
    /// **Linux/Mac:**
    /// ```bash
    /// export GIGACHAT_TOKEN="your_secret_token"
    /// ```
    ///
    /// **Windows PowerShell:**
    /// ```powershell
    /// $env:GIGACHAT_TOKEN="your_secret_token"
    /// ```
    ///
    /// **Через .env файл (для разработки):**
    /// ```text
    /// # .env (добавьте в .gitignore!)
    /// GIGACHAT_TOKEN=your_secret_token
    /// ```
    pub fn get_gigachat_token(&self) -> Result<String, ConfigError> {
        // env::var возвращает Result<String, VarError>
        // map_err преобразует VarError → ConfigError
        env::var("GIGACHAT_TOKEN").map_err(ConfigError::from)
    }

    /// Проверяет, включён ли режим разработки.
    ///
    /// В режиме разработки можно включать дополнительное логирование,
    /// отключать кеширование и т.д.
    pub fn is_development(&self) -> bool {
        self.server.environment == "development"
    }

    /// Проверяет, включён ли GigaChat API в конфигурации.
    pub fn is_gigachat_enabled(&self) -> bool {
        self.gigachat.enabled
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_config_load() {
        // Этот тест проверяет, что конфигурация загружается без ошибок
        // В реальном проекте здесь могут быть более детальные тесты
        let result = AppConfig::load();
        assert!(result.is_ok() || result.is_err()); // Просто проверяем, что функция работает
    }
}
